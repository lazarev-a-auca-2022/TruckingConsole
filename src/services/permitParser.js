const fs = require('fs-extra');
const path = require('path');
const logger = require('../utils/logger');
const OpenRouterOCR = require('./openRouterOcr');
const RouteVerificationService = require('./routeVerificationService');
const AIPermitParser = require('./aiPermitParser');

// Supported states for AI parsing
const SUPPORTED_STATES = ['IL', 'WI', 'MO', 'ND', 'IN', 'VA', 'TX'];

/**
 * Convert PDF to images using Ghostscript
 * @param {string} pdfPath - Path to PDF file
 * @returns {Promise<string[]>} - Array of PNG file paths
 */
async function convertPdfToImages(pdfPath) {
  try {
    logger.info(`Converting PDF to images using Ghostscript: ${pdfPath}`);
    
    // Validate input path to prevent command injection
    if (!pdfPath || typeof pdfPath !== 'string') {
      throw new Error('Invalid PDF path provided');
    }
    
    // Ensure the file exists before processing
    if (!await fs.pathExists(pdfPath)) {
      throw new Error(`PDF file not found: ${pdfPath}`);
    }
    
    const outputDir = path.join(path.dirname(pdfPath), 'pdf-images');
    await fs.ensureDir(outputDir);
    
    // Ghostscript output pattern - will create page-1.png, page-2.png, etc.
    const outputPattern = path.join(outputDir, 'page-%d.png');
    
    // Use array of arguments to prevent command injection
    const gsArgs = [
      '-dNOPAUSE',
      '-dBATCH',
      '-sDEVICE=png16m',
      '-r200',
      `-sOutputFile=${outputPattern}`,
      pdfPath
    ];
    
    logger.info(`Executing Ghostscript with args: ${JSON.stringify(gsArgs)}`);
    
    // Execute Ghostscript with proper error handling
    try {
      // Use spawn with shell disabled for better security
      const { spawn } = require('child_process');
      await new Promise((resolve, reject) => {
        const gs = spawn('gs', gsArgs, { shell: false });
        
        let stderr = '';
        
        gs.stderr.on('data', (data) => {
          stderr += data.toString();
        });
        
        gs.on('close', (code) => {
          if (code !== 0) {
            reject(new Error(`Ghostscript exited with code ${code}: ${stderr}`));
          } else {
            resolve();
          }
        });
        
        gs.on('error', (err) => {
          if (err.code === 'ENOENT') {
            reject(new Error('Ghostscript is not installed or not in PATH. Please ensure Ghostscript (gs) is installed.'));
          } else {
            reject(err);
          }
        });
      });
    } catch (gsError) {
      // Provide specific error messages based on the failure
      if (gsError.message.includes('ENOENT')) {
        throw new Error('Ghostscript is not installed. Please install Ghostscript (gs) to convert PDFs.');
      } else if (gsError.message.includes('exited with code')) {
        throw new Error(`Ghostscript conversion failed: ${gsError.message}`);
      } else {
        throw gsError;
      }
    }
    
    // Read the output directory to find all generated PNG files
    const files = await fs.readdir(outputDir);
    const pngFiles = files
      .filter(file => file.endsWith('.png'))
      .sort((a, b) => {
        // Sort by page number - extract from pattern 'page-N.png'
        const matchA = a.match(/page-(\d+)\.png/);
        const matchB = b.match(/page-(\d+)\.png/);
        const numA = matchA ? parseInt(matchA[1]) : 0;
        const numB = matchB ? parseInt(matchB[1]) : 0;
        return numA - numB;
      })
      .map(file => path.join(outputDir, file));
    
    if (pngFiles.length === 0) {
      throw new Error('No PNG files were generated by Ghostscript. The PDF may be corrupted or empty.');
    }
    
    logger.info(`‚úÖ Converted PDF to ${pngFiles.length} images using Ghostscript`);
    
    return pngFiles;
    
  } catch (error) {
    logger.error(`PDF to image conversion failed: ${error.message}`);
    throw new Error(`Failed to convert PDF to images: ${error.message}`);
  }
}

async function parsePermit(filePath, state = null) {
  try {
    logger.info(`Starting permit parsing for file: ${filePath}, state: ${state || 'auto-detect'}`);
    
    // Validate file exists
    if (!await fs.pathExists(filePath)) {
      throw new Error(`File not found: ${filePath}`);
    }

    // Auto-detect state if not provided
    if (!state) {
      logger.info('No state provided, attempting automatic detection...');
      
      const fileExtension = path.extname(filePath).toLowerCase();
      
      // Only auto-detect for images (PDFs might be encrypted)
      if (isImageFile(filePath) && process.env.OPENROUTER_API_KEY) {
        try {
          const ocr = new OpenRouterOCR();
          const detectedState = await ocr.detectState(filePath);
          
          if (detectedState !== 'UNKNOWN') {
            state = detectedState;
            logger.info(`‚úÖ Auto-detected state: ${state}`);
          } else {
            logger.warn('Could not auto-detect state, defaulting to Illinois');
            state = 'IL';
          }
        } catch (error) {
          logger.error(`State detection failed: ${error.message}, defaulting to Illinois`);
          state = 'IL';
        }
      } else {
        logger.info('');
        state = 'IL';
      }
    }
    
    // Validate state
    if (!SUPPORTED_STATES.includes(state)) {
      throw new Error(`Unsupported state: ${state}. Supported states: ${SUPPORTED_STATES.join(', ')}`);
    }
    
    let extractedText;
    const fileExtension = path.extname(filePath).toLowerCase();
    
    // Determine file type and extract text accordingly
    if (fileExtension === '.pdf') {
      logger.info('üìÑ Processing PDF directly with Claude Sonnet 4.5 (PDF native support)...');
      
      if (!process.env.OPENROUTER_API_KEY) {
        throw new Error('OpenRouter API key is required for PDF processing. Please set OPENROUTER_API_KEY in docker-compose.yml');
      }
      
      try {
        // Convert PDF to images for processing (Claude doesn't support PDFs via OpenRouter)
        logger.info('üì∏ Converting PDF to images for processing...');
        const imagePaths = await convertPdfToImages(filePath);
        const imageDir = path.dirname(imagePaths[0]);
        
        logger.info(`üîç Scanning all ${imagePaths.length} pages for routing tables...`);
        const verificationService = new RouteVerificationService();
        
        let verificationResult = null;
        let successfulPage = null;
        
        // Try each page until we find routing information
        for (let i = 0; i < imagePaths.length; i++) {
          const pageNum = i + 1;
          logger.info(`üìÑ Checking page ${pageNum}/${imagePaths.length} for routing data...`);
          
          try {
            const pageResult = await verificationService.processPermitRoute(imagePaths[i], { 
              state, 
              pageNumber: pageNum,
              totalPages: imagePaths.length 
            });
            
            // If we successfully extracted waypoints, use this page
            if (pageResult.success && pageResult.geocodedWaypoints && pageResult.geocodedWaypoints.length > 0) {
              verificationResult = pageResult;
              successfulPage = pageNum;
              logger.info(`‚úÖ Found routing table on page ${pageNum} with ${pageResult.geocodedWaypoints.length} waypoints!`);
              break;
            } else {
              logger.info(`   ‚è© Page ${pageNum} has no routing data, continuing...`);
            }
          } catch (pageError) {
            logger.warn(`   ‚ö†Ô∏è  Page ${pageNum} processing failed: ${pageError.message}, continuing...`);
            // Continue to next page
          }
        }
        
        // If no page had routing data, fail
        if (!verificationResult) {
          throw new Error(`No routing tables found in any of the ${imagePaths.length} pages`);
        }
        
        // Store verification result for later use in mapsService
        if (!parsePermit.verificationCache) {
          parsePermit.verificationCache = new Map();
        }
        parsePermit.verificationCache.set(filePath, verificationResult);
        logger.info(`‚úÖ PDF coordinate verification completed with ${verificationResult.geocodedWaypoints.length} geocoded waypoints from page ${successfulPage}`);
        
        // Clean up temporary images
        await fs.remove(imageDir);
        logger.info('üóëÔ∏è  Cleaned up temporary image files');
        
        // Use extracted waypoint data as text for AI parser (minimal text extraction)
        const waypointSummary = verificationResult.geocodedWaypoints
          .map(wp => `${wp.address} (${wp.type})`)
          .join('\n');
        
        extractedText = `Route extracted via coordinate verification:\n${waypointSummary}`;
        logger.info(`‚úÖ Using coordinate-based route data from PDF via image processing`);
        
      } catch (pdfError) {
        logger.error(`‚ùå PDF vision processing failed: ${pdfError.message}`);
        throw new Error(`Unable to process PDF: ${pdfError.message}`);
      }
    } else if (isImageFile(filePath)) {
      logger.info('Processing image file with NEW double-check verification workflow...');
      
      if (!process.env.OPENROUTER_API_KEY) {
        throw new Error('OpenRouter API key is required for image processing. Please set OPENROUTER_API_KEY in docker-compose.yml');
      }
      
      // NEW WORKFLOW: Use RouteVerificationService for double-checking
      const verificationService = new RouteVerificationService();
      const verificationResult = await verificationService.processPermitRoute(filePath);
      
      // Store verification result for later use in mapsService
      if (!parsePermit.verificationCache) {
        parsePermit.verificationCache = new Map();
      }
      parsePermit.verificationCache.set(filePath, verificationResult);
      
      // For backwards compatibility, still extract text for state parsers
      const ocr = new OpenRouterOCR();
      const templatePath = path.join(__dirname, '../../outputs/permit-template-IL.png');
      const result = await ocr.processPermit(filePath, templatePath);
      
      // Try to get text from rawText first, then from extracted fields
      extractedText = result.extractedData.rawText;
      
      if (!extractedText || extractedText.trim().length === 0) {
        // If no rawText, try to combine extracted fields
        const fieldValues = Object.values(result.extractedData.extractedFields).filter(v => v && v.trim());
        extractedText = fieldValues.join(' ');
      }
      
      // If still no text, use a fallback approach
      if (!extractedText || extractedText.trim().length === 0) {
        logger.warn('No text extracted via structured approach, requesting raw OCR');
        const simpleOcr = new OpenRouterOCR();
        const rawOcrResult = await simpleOcr.extractRawText(filePath);
        extractedText = rawOcrResult;
      }
      
      logger.info(`OpenRouter OCR completed with confidence: ${result.extractedData.confidence}`);
      logger.info(`Route verification completed with ${verificationResult.geocodedWaypoints.length} waypoints`);
    } else {
      throw new Error(`Unsupported file format: ${fileExtension}. Supported formats: .pdf, .png, .jpg, .jpeg, .gif, .bmp, .tiff, .webp`);
    }
    
    if (!extractedText || extractedText.trim().length === 0) {
      throw new Error('No text could be extracted from the file');
    }
    
    logger.info(`Extracted ${extractedText.length} characters from ${fileExtension.substring(1).toUpperCase()}`);
    
    // Use AI parsing (required - no fallback to manual parsers)
    if (!process.env.OPENROUTER_API_KEY) {
      throw new Error('OpenRouter API key is required. Please set OPENROUTER_API_KEY in docker-compose.yml');
    }
    
    if (process.env.USE_AI_PARSER === 'false') {
      throw new Error('AI parsing is disabled but manual parsers have been removed. Set USE_AI_PARSER=true');
    }
    
    logger.info('Using AI-powered parsing...');
    const aiParser = new AIPermitParser();
    const parseResult = await aiParser.parsePermit(extractedText, state);
    
    if (!parseResult || parseResult.waypoints.length === 0) {
      logger.warn(`‚ö†Ô∏è  AI parsing returned no waypoints. Parse accuracy: ${parseResult?.parseAccuracy || 0}`);
    } else {
      logger.info(`‚úÖ AI parsing successful with ${parseResult.parseAccuracy * 100}% confidence`);
      logger.info(`   Extracted ${parseResult.waypoints.length} waypoints`);
    }
    
    // Generate unique route ID
    const routeId = generateRouteId();
    
    const result = {
      routeId,
      state,
      fileType: fileExtension.substring(1),
      originalText: extractedText,
      parseResult,
      timestamp: new Date().toISOString(),
      filePath: filePath, // Keep full path for OpenRouter OCR
      fileName: path.basename(filePath)
    };
    
    // Add verification data if available (for images)
    if (parsePermit.verificationCache && parsePermit.verificationCache.has(filePath)) {
      const verificationData = parsePermit.verificationCache.get(filePath);
      result.verificationData = verificationData;
      result.mapsJson = verificationData.mapsJson; // Add the Google Maps compatible JSON
      logger.info(`‚úÖ Added verification data with ${verificationData.geocodedWaypoints.length} geocoded waypoints`);
    }
    
    logger.info(`Successfully parsed permit for state: ${state}`);
    return result;
    
  } catch (error) {
    logger.error(`Permit parsing failed: ${error.message}`);
    throw error;
  }
}

function generateRouteId() {
  return 'route_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

/**
 * Determine if a file is an image based on its extension
 */
function isImageFile(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.webp'];
  return imageExtensions.includes(ext);
}

/**
 * Get demo text for state-specific parsing demonstration
 */
module.exports = {
  parsePermit,
  convertPdfToImages,
  generateRouteId,
  isImageFile
};
